#pragma once

#include "x86_call.h"

#include <concepts>
#include <utility>

namespace fd
{
template <typename From, typename To>
class magic_cast;

class vfunc_holder
{
    void *func_;

  public:
    vfunc_holder(void *vfunc)
        : func_(vfunc)
    {
    }

    vfunc_holder(void *instance, size_t table_offset, size_t func_index)
        : func_(static_cast<void ***>(instance)[table_offset][func_index])
    {
    }

    operator void *() const
    {
        return func_;
    }

    void *get() const
    {
        return func_;
    }
};

template <typename T>
class vfunc_instance_holder
{
    T *instance_;

  public:
    vfunc_instance_holder(T *instance)
        : instance_((instance))
    {
    }

    T *instance() const
    {
        return instance_;
    }
};

// inline size_t get_vfunc_index(void *instance, size_t vtable_offset, size_t index, _x86_call call)
//{
//     return index;
// }

size_t get_vfunc_index(void *instance, size_t vtable_offset, void *function, _x86_call call);

template <typename Fn>
size_t get_vfunc_index(void *instance, size_t vtable_offset, Fn *function)
{
    static_assert(sizeof(Fn *) == sizeof(void *));

    union
    {
        Fn fn;
        void *fn_ptr;
    };

    fn = function;

    return get_vfunc_index(instance, vtable_offset, fn_ptr, get_call_type(function));
}

//#define GET_VFUNC_INDEX(call__, __call)                                                              \
//    template <typename Ret, typename T, typename... Args>                                            \
//    size_t get_vfunc_index(void *instance, size_t vtable_offset, Ret (__call T::*function)(Args...)) \
//    {                                                                                                \
//        return get_vfunc_index(instance, vtable_offset, member_function_pointer(function), call__);  \
//    }
//
// X86_CALL_MEMBER(GET_VFUNC_INDEX);
// #undef GET_VFUNC_INDEX

template <_x86_call Call, typename Ret, typename T, typename... Args>
struct vfunc_x86;

template <typename Ret, typename T, typename... Args>
struct vfunc_x86<_x86_call::unknown, Ret, T, Args...> : vfunc_holder
{
    using vfunc_holder::vfunc_holder;
};

template <typename T>
vfunc_x86(T *, size_t) -> vfunc_x86<_x86_call::unknown, void, T>;

template <_x86_call Call, typename Ret, typename T, typename... Args>
struct vfunc_invoker;

struct vfunc_invoker_gap
{
};

#define VFUNC_INVOKER(call__, __call)                                                                   \
    template <typename Ret, typename T, typename... Args>                                               \
    struct vfunc_invoker<call__, Ret, T, Args...>                                                       \
    {                                                                                                   \
        template <typename Fn, typename... Args2>                                                       \
        static Ret call(T *instance, Fn *fn, Args2 &&...args) noexcept                                  \
        {                                                                                               \
            union                                                                                       \
            {                                                                                           \
                Fn *fn1;                                                                                \
                Ret (__call vfunc_invoker_gap::*fn2)(Args...);                                          \
            };                                                                                          \
            fn1 = fn;                                                                                   \
            return (*reinterpret_cast<vfunc_invoker_gap *>(instance).*fn2)(static_cast<Args>(args)...); \
        }                                                                                               \
    };

X86_CALL_MEMBER(VFUNC_INVOKER);
#undef VFUNC_INVOKER

template <typename Ret, typename T, typename... Args>
struct vfunc_invoker<_x86_call::unknown, Ret, T, Args...>
{
    template <typename... Args2>
    static Ret call(void *instance, auto *fn, _x86_call info, Args2 &&...args) noexcept
    {
#define SELECT_INVOKER(call__, __call) \
    case call__:                       \
        vfunc_invoker<call__, Ret, T, Args...>::call(instance, fn, std::forward<Args2>(args)...);

        switch (info)
        {
            X86_CALL_MEMBER(SELECT_INVOKER);
        default:
            std::unreachable();
        }

#undef SELECT_INVOKER
    }

    template <typename... Args2>
    static Ret call(void *instance, auto *fn, Args2 &&...args) noexcept
    {
        return call(instance, fn, get_call_type(fn), std::forward<Args2>(args)...);
    }
};

template <_x86_call Call, typename Ret, typename T, typename... Args>
class vfunc1
{
    T *instance_;
    void *func_;

  public:
    vfunc1(T *instance, size_t table_offset, size_t func_index)
        : instance_(instance)
        , func_(static_cast<void ***>(instance)[table_offset][func_index])
    {
    }

    vfunc1(T *instance, size_t table_offset, auto *func)
        : vfunc1(instance, table_offset, get_vfunc_index(instance, table_offset, func))
    {
    }

    template <typename... Args2>
    Ret operator()(Args2 &&...args) const
    {
        return vfunc_invoker<Call, Ret, T, Args...>::call(instance_, func_, std::forward<Args2>(args)...);
    }
};

template <_x86_call Call, typename T>
class vfunc1<Call, nullptr_t, T>
{
    T *instance_;
    void *func_;

  public:
    vfunc1(T *instance, size_t table_offset, size_t func_index)
        : instance_(instance)
        , func_(static_cast<void ***>(instance)[table_offset][func_index])
    {
    }

    vfunc1(T *instance, size_t table_offset, auto *func)
        : vfunc1(instance, table_offset, get_vfunc_index(instance, table_offset, func))
    {
    }

    template <typename Ret, typename... Args>
    Ret operator()(std::in_place_type_t<Ret>, Args... args) const
    {
        return vfunc_invoker<Call, Ret, T, Args...>::call(instance_, func_, static_cast<Args>(args)...);
    }
};

template <typename T>
class vfunc1<_x86_call::unknown, nullptr_t, T>
{
    T *instance_;
    _x86_call call_;
    void *func_;

  public:
    vfunc1(T *instance, size_t table_offset, _x86_call call, size_t func_index)
        : instance_(instance)
        , call_(call)
        , func_(static_cast<void ***>(instance)[table_offset][func_index])
    {
    }

    vfunc1(T *instance, size_t table_offset, auto *func)
        : vfunc1(instance, table_offset, get_call_type(func), get_vfunc_index(instance, table_offset, func))
    {
    }

    template <typename Ret, typename... Args>
    Ret operator()(std::in_place_type_t<Ret>, Args... args) const
    {
        return vfunc_invoker<_x86_call::unknown, Ret, T, Args...>::call(
            instance_, func_, call_, static_cast<Args>(args)...);
    }
};

template <typename Ret, typename T, typename... Args>
class vfunc1<_x86_call::unknown, Ret, T, Args...>
{
    T *instance_;
    _x86_call call_;
    void *func_;

  public:
    vfunc1(T *instance, size_t table_offset, _x86_call call, size_t func_index)
        : instance_(instance)
        , call_(call)
        , func_(static_cast<void ***>(instance)[table_offset][func_index])
    {
    }

    vfunc1(T *instance, size_t table_offset, auto *func)
        : vfunc1(instance, table_offset, get_call_type(func), get_vfunc_index(instance, table_offset, func))
    {
    }

    template <typename... Args2>
    Ret operator()(Args2 &&...args) const
    {
        return vfunc_invoker<_x86_call::unknown, Ret, T, Args...>::call(
            instance_, func_, call_, std::forward<Args2>(args)...);
    }
};

#define VFUNC_T(call__, __call)                           \
    template <typename Ret, typename T, typename... Args> \
    vfunc1(T *instance, size_t table_offset, Ret(__call T::*func)) -> vfunc1<call__, Ret, T, Args...>;

X86_CALL_MEMBER(VFUNC_T);
#undef VFUNC_T

#define VFUNC_X86(call__, __call)                                                                            \
    template <typename Ret, typename T, typename... Args>                                                    \
    struct vfunc_x86<call__, Ret, T, Args...> : vfunc_instance_holder<T>, vfunc_holder                       \
    {                                                                                                        \
        vfunc_x86(T *instance, size_t table_offset, Ret (__call T::*fn)(Args...))                            \
            : vfunc_instance_holder<T>(instance)                                                             \
            , vfunc_holder(instance, table_offset, get_vfunc_index(instance, table_offset, fn))              \
        {                                                                                                    \
        }                                                                                                    \
        vfunc_x86(T *instance, Ret (__call T::*fn)(Args...))                                                 \
            : vfunc_x86(instance, 0, fn)                                                                     \
        {                                                                                                    \
        }                                                                                                    \
        Ret operator()(Args... args) const                                                                   \
        {                                                                                                    \
            return x86_invoker<call__, Ret>(this->instance(), this->get(), static_cast<Args>(args)...);      \
        }                                                                                                    \
    };                                                                                                       \
    template <typename Ret, typename T, typename... Args>                                                    \
    vfunc_x86<call__, Ret, T, Args...> vfunc(T *instance, size_t table_offset, Ret (__call T::*fn)(Args...)) \
    {                                                                                                        \
        return {instance, table_offset, fn};                                                                 \
    }                                                                                                        \
    template <typename Ret, typename T, typename... Args>                                                    \
    vfunc_x86<call__, Ret, T, Args...> vfunc(T *instance, Ret (__call T::*fn)(Args...))                      \
    {                                                                                                        \
        return {instance, fn};                                                                               \
    }                                                                                                        \
    template <typename Ret, typename T, typename... Args>                                                    \
    vfunc_x86(T *, size_t, Ret (__call T::*)(Args...)) -> vfunc_x86<call__, Ret, T, Args...>;                \
    template <typename Ret, typename T, typename... Args>                                                    \
    vfunc_x86(T *, Ret (__call T::*)(Args...)) -> vfunc_x86<call__, Ret, T, Args...>;

X86_CALL_MEMBER(VFUNC_X86);
#undef VFUNC_X86

template <typename T>
constexpr _x86_call vtable_call = _x86_call::unknown;

template <typename T>
struct vtable
{
    using instance_pointer = T *;
    using table_pointer    = void **;

  private:
    instance_pointer instance_;
    size_t vtable_offset_;

  public:
    vtable(instance_pointer instance = nullptr, size_t vtable_offset = 0)
        : instance_(instance)
        , vtable_offset_(vtable_offset)
    {
    }

    template <typename From, typename To>
    [[deprecated]] //
    vtable(magic_cast<From, To> val, size_t vtable_offset = 0)
        : instance_(val)
        , vtable_offset_(vtable_offset)
    {
    }

    /*vtable &operator=(std::convertible_to<pointer> auto instance)
    {
        instance_ = instance;
        return *this;
    }*/

    operator instance_pointer() const
    {
        return instance_;
    }

    instance_pointer operator->() const
    {
        return instance_;
    }

    operator table_pointer() const
    {
        return static_cast<void ***>(instance_)[vtable_offset_];
    }

    table_pointer get() const
    {
        return static_cast<void ***>(instance_)[vtable_offset_];
    }

    void set(table_pointer pointer) const
    {
        static_cast<void ***>(instance_)[vtable_offset_] = pointer;
    }

  private:
    void *func_simple(size_t index) const
    {
        return static_cast<void ***>(instance_)[vtable_offset_][index];
    }

  public:
    vfunc1<_x86_call::unknown, void, void> func(size_t index) const
    {
        return {instance_, vtable_offset_, index};
    }

    template <typename Ret, typename... Args>
    vfunc_x86<vtable_call<T>, Ret, T, Args...> func(size_t index) const
    {
        return {instance_, vtable_offset_, index};
    }

#define VFUNC_GET(call__, __call)                                               \
    template <typename Ret, typename Q = T, typename... Args>                   \
    vfunc_x86<call__, Ret, Q, Args...> func(Ret (__call Q::*fn)(Args...)) const \
    {                                                                           \
        return {instance_, vtable_offset_, fn};                                 \
    }
    X86_CALL_MEMBER(VFUNC_GET)
#undef VFUNC_GET

    template <typename Ret, typename... Args>
    Ret call(size_t index, Args... args) const
    {
        return x86_invoker<_x86_call::thiscall__, Ret>(instance_, func_simple(index), static_cast<Args>(args)...);
    }

    template <_x86_call Call, typename Ret, typename... Args>
    Ret call(size_t index, Args... args) const
    {
        return x86_invoker<Call, Ret>(instance_, func_simple(index), static_cast<Args>(args)...);
    }

    /*template <typename Ret = void, typename... Args>
    Ret call(size_t index, Args... args) const
    {
        return vfunc<Ret, Args...>(instance_, index)(
            static_cast<std::conditional_t<
                std::is_trivially_copyable_v<Args> ? std::is_pointer_v<Args> || sizeof(Args) <= sizeof(uintptr_t[2])
                                                   : std::is_reference_v<Args>,
                Args,
                std::add_lvalue_reference_t<Args>>>(args)...);
    }*/
};

template <typename T>
struct vtable<T *>
{
    vtable(...) = delete;
};

// template <typename T>
// auto exchange(vtable<T> table, typename vtable<T>::table_pointer ptr) -> decltype(ptr)
//{
//     auto backup = table.get();
//     table.set(ptr);
//     return backup;
// }

template <typename T, typename T2 = void>
auto exchange(vtable<T> table, vtable<T2> other) -> typename vtable<T>::table_pointer
{
    auto backup = table.get();
    table.set(other.get());
    return backup;
}

template <typename From, typename To>
vtable(magic_cast<From, To *>) -> vtable<To>;

struct auto_cast_tag;

template <typename From>
vtable(magic_cast<From, auto_cast_tag>) -> vtable<void>;

// template <typename T>
// class vtable<T *> : public vtable<T>
//{
//   public:
//     using vtable<T>::vtable;
//     using vtable<T>::operator=;
// };
//
// template <typename T>
// class vtable<T **>
//{
//   public:
//     vtable(...) = delete;
// };

// template <typename T>
// vtable(T instance) -> vtable<std::conditional_t<std::is_pointer_v<T>, std::remove_pointer_t<T>, void>>;

template <typename T>
vtable(vtable<T>) -> vtable<void **>; // deleted

template <typename T>
struct cast_helper;

template <typename From, typename To>
vtable(magic_cast<From, cast_helper<To *>>) -> vtable<To>;

template <typename From, typename To>
magic_cast(vtable<From>, To) -> magic_cast<From *, To>;

// template <typename From, typename To>
// magic_cast(vtable<From *>, To) -> magic_cast<From *, To>;

template <_x86_call Call, typename Ret, typename T, typename To, typename... Args>
magic_cast(vfunc_x86<Call, Ret, T, Args...>, To) -> magic_cast<T *, To>;

template <typename To>
magic_cast(vfunc_holder, To) -> magic_cast<void *, To>;

// template <typename T>
// vtable(T const *instance) -> vtable<T const *>;

} // namespace fd

namespace std

{
template <typename T>
void **exchange(fd::vtable<T> vt, void **new_table)
{
    void **old_table = vt;
}
}