#include "C_BasePlayer.h"
#include "cheat/netvars/netvars.h"
#include <nstd/address.h>

#include "cheat/csgo/CBaseHandle.hpp"
#include "cheat/csgo/CBaseHandle.hpp"
#include "cheat/csgo/Vector.hpp"
#include <array>

using namespace cheat::csgo;

std::array<int, 32>& C_BasePlayer::m_chAreaBits( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_chAreaBits");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<std::array<int, 32>>( );
}
std::array<int, 24>& C_BasePlayer::m_chAreaPortalBits( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_chAreaPortalBits");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<std::array<int, 24>>( );
}
int& C_BasePlayer::m_iHideHUD( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_iHideHUD");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int>( );
}
float& C_BasePlayer::m_flFOVRate( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_flFOVRate");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<float>( );
}
bool& C_BasePlayer::m_bDucked( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_bDucked");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<bool>( );
}
bool& C_BasePlayer::m_bDucking( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_bDucking");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<bool>( );
}
float& C_BasePlayer::m_flLastDuckTime( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_flLastDuckTime");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<float>( );
}
bool& C_BasePlayer::m_bInDuckJump( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_bInDuckJump");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<bool>( );
}
int& C_BasePlayer::m_nDuckTimeMsecs( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_nDuckTimeMsecs");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int>( );
}
int& C_BasePlayer::m_nDuckJumpTimeMsecs( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_nDuckJumpTimeMsecs");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int>( );
}
int& C_BasePlayer::m_nJumpTimeMsecs( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_nJumpTimeMsecs");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int>( );
}
float& C_BasePlayer::m_flFallVelocity( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_flFallVelocity");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<float>( );
}
cheat::csgo::Vector& C_BasePlayer::m_viewPunchAngle( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_viewPunchAngle");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<cheat::csgo::Vector>( );
}
cheat::csgo::Vector& C_BasePlayer::m_aimPunchAngle( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_aimPunchAngle");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<cheat::csgo::Vector>( );
}
cheat::csgo::Vector& C_BasePlayer::m_aimPunchAngleVel( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_aimPunchAngleVel");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<cheat::csgo::Vector>( );
}
bool& C_BasePlayer::m_bDrawViewmodel( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_bDrawViewmodel");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<bool>( );
}
bool& C_BasePlayer::m_bWearingSuit( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_bWearingSuit");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<bool>( );
}
bool& C_BasePlayer::m_bPoisoned( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_bPoisoned");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<bool>( );
}
float& C_BasePlayer::m_flStepSize( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_flStepSize");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<float>( );
}
bool& C_BasePlayer::m_bAllowAutoMovement( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_bAllowAutoMovement");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<bool>( );
}
cheat::csgo::Vector& C_BasePlayer::m_vecViewOffset( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_vecViewOffset");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<cheat::csgo::Vector>( );
}
float& C_BasePlayer::m_flFriction( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_flFriction");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<float>( );
}
int& C_BasePlayer::m_fOnTarget( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_fOnTarget");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int>( );
}
int& C_BasePlayer::m_nTickBase( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_nTickBase");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int>( );
}
int& C_BasePlayer::m_nNextThinkTick( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_nNextThinkTick");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int>( );
}
cheat::csgo::CBaseHandle& C_BasePlayer::m_hLastWeapon( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_hLastWeapon");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<cheat::csgo::CBaseHandle>( );
}
cheat::csgo::Vector& C_BasePlayer::m_vecVelocity( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_vecVelocity");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<cheat::csgo::Vector>( );
}
cheat::csgo::Vector& C_BasePlayer::m_vecBaseVelocity( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_vecBaseVelocity");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<cheat::csgo::Vector>( );
}
cheat::csgo::CBaseHandle& C_BasePlayer::m_hConstraintEntity( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_hConstraintEntity");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<cheat::csgo::CBaseHandle>( );
}
cheat::csgo::Vector& C_BasePlayer::m_vecConstraintCenter( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_vecConstraintCenter");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<cheat::csgo::Vector>( );
}
float& C_BasePlayer::m_flConstraintRadius( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_flConstraintRadius");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<float>( );
}
float& C_BasePlayer::m_flConstraintWidth( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_flConstraintWidth");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<float>( );
}
float& C_BasePlayer::m_flConstraintSpeedFactor( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_flConstraintSpeedFactor");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<float>( );
}
bool& C_BasePlayer::m_bConstraintPastRadius( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_bConstraintPastRadius");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<bool>( );
}
float& C_BasePlayer::m_flDeathTime( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_flDeathTime");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<float>( );
}
float& C_BasePlayer::m_flNextDecalTime( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_flNextDecalTime");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<float>( );
}
float& C_BasePlayer::m_fForceTeam( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_fForceTeam");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<float>( );
}
float& C_BasePlayer::m_flLaggedMovementValue( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_flLaggedMovementValue");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<float>( );
}
cheat::csgo::CBaseHandle& C_BasePlayer::m_hTonemapController( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_hTonemapController");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<cheat::csgo::CBaseHandle>( );
}
int& C_BasePlayer::deadflag( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "deadflag");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int>( );
}
int& C_BasePlayer::m_iFOV( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_iFOV");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int>( );
}
int& C_BasePlayer::m_iFOVStart( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_iFOVStart");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int>( );
}
float& C_BasePlayer::m_flFOVTime( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_flFOVTime");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<float>( );
}
int& C_BasePlayer::m_iDefaultFOV( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_iDefaultFOV");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int>( );
}
cheat::csgo::CBaseHandle& C_BasePlayer::m_hZoomOwner( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_hZoomOwner");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<cheat::csgo::CBaseHandle>( );
}
int& C_BasePlayer::m_afPhysicsFlags( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_afPhysicsFlags");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int>( );
}
cheat::csgo::CBaseHandle& C_BasePlayer::m_hVehicle( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_hVehicle");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<cheat::csgo::CBaseHandle>( );
}
cheat::csgo::CBaseHandle& C_BasePlayer::m_hUseEntity( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_hUseEntity");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<cheat::csgo::CBaseHandle>( );
}
cheat::csgo::CBaseHandle& C_BasePlayer::m_hGroundEntity( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_hGroundEntity");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<cheat::csgo::CBaseHandle>( );
}
int& C_BasePlayer::m_iHealth( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_iHealth");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int>( );
}
int& C_BasePlayer::m_lifeState( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_lifeState");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int>( );
}
std::array<int, 32>& C_BasePlayer::m_iAmmo( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_iAmmo");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<std::array<int, 32>>( );
}
int& C_BasePlayer::m_iBonusProgress( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_iBonusProgress");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int>( );
}
int& C_BasePlayer::m_iBonusChallenge( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_iBonusChallenge");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int>( );
}
float& C_BasePlayer::m_flMaxspeed( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_flMaxspeed");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<float>( );
}
int& C_BasePlayer::m_fFlags( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_fFlags");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int>( );
}
int& C_BasePlayer::m_iObserverMode( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_iObserverMode");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int>( );
}
bool& C_BasePlayer::m_bActiveCameraMan( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_bActiveCameraMan");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<bool>( );
}
bool& C_BasePlayer::m_bCameraManXRay( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_bCameraManXRay");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<bool>( );
}
bool& C_BasePlayer::m_bCameraManOverview( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_bCameraManOverview");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<bool>( );
}
bool& C_BasePlayer::m_bCameraManScoreBoard( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_bCameraManScoreBoard");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<bool>( );
}
int& C_BasePlayer::m_uCameraManGraphs( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_uCameraManGraphs");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int>( );
}
int& C_BasePlayer::m_iDeathPostEffect( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_iDeathPostEffect");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int>( );
}
cheat::csgo::CBaseHandle& C_BasePlayer::m_hObserverTarget( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_hObserverTarget");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<cheat::csgo::CBaseHandle>( );
}
std::array<cheat::csgo::CBaseHandle, 3>& C_BasePlayer::m_hViewModel( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_hViewModel");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<std::array<cheat::csgo::CBaseHandle, 3>>( );
}
int& C_BasePlayer::m_iCoachingTeam( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_iCoachingTeam");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int>( );
}
char* C_BasePlayer::m_szLastPlaceName( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_szLastPlaceName");
	auto addr = nstd::address(this).add(offset);
	return addr.ptr<char>( );
}
cheat::csgo::Vector& C_BasePlayer::m_vecLadderNormal( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_vecLadderNormal");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<cheat::csgo::Vector>( );
}
int& C_BasePlayer::m_ladderSurfaceProps( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_ladderSurfaceProps");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int>( );
}
int& C_BasePlayer::m_ubEFNoInterpParity( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_ubEFNoInterpParity");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int>( );
}
cheat::csgo::CBaseHandle& C_BasePlayer::m_hPostProcessCtrl( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_hPostProcessCtrl");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<cheat::csgo::CBaseHandle>( );
}
cheat::csgo::CBaseHandle& C_BasePlayer::m_hColorCorrectionCtrl( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_hColorCorrectionCtrl");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<cheat::csgo::CBaseHandle>( );
}
int& C_BasePlayer::m_vphysicsCollisionState( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_vphysicsCollisionState");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int>( );
}
cheat::csgo::CBaseHandle& C_BasePlayer::m_hViewEntity( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_hViewEntity");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<cheat::csgo::CBaseHandle>( );
}
bool& C_BasePlayer::m_bShouldDrawPlayerWhileUsingViewEntity( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_bShouldDrawPlayerWhileUsingViewEntity");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<bool>( );
}
float& C_BasePlayer::m_flDuckAmount( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_flDuckAmount");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<float>( );
}
float& C_BasePlayer::m_flDuckSpeed( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_flDuckSpeed");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<float>( );
}
int& C_BasePlayer::m_nWaterLevel( )
{
	static const auto offset = netvars::get_ptr( )->at("C_BasePlayer", "m_nWaterLevel");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int>( );
}
