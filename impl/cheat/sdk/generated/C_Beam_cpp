#include "C_Beam.h"

#include "cheat/core/netvars.h"

using namespace cheat;
using namespace csgo;

int32_t& C_Beam::m_nBeamType( )
{
	static const auto offset = netvars::get_ptr( )->at("C_Beam.m_nBeamType");
	auto addr = utl::mem::address(this).add(offset);
	return addr.ref<int32_t>( );
}
int32_t& C_Beam::m_nBeamFlags( )
{
	static const auto offset = netvars::get_ptr( )->at("C_Beam.m_nBeamFlags");
	auto addr = utl::mem::address(this).add(offset);
	return addr.ref<int32_t>( );
}
int32_t& C_Beam::m_nNumBeamEnts( )
{
	static const auto offset = netvars::get_ptr( )->at("C_Beam.m_nNumBeamEnts");
	auto addr = utl::mem::address(this).add(offset);
	return addr.ref<int32_t>( );
}
utl::array<int32_t, 10>& C_Beam::m_hAttachEntity( )
{
	static const auto offset = netvars::get_ptr( )->at("C_Beam.m_hAttachEntity");
	auto addr = utl::mem::address(this).add(offset);
	return addr.ref<utl::array<int32_t, 10>>( );
}
utl::array<int32_t, 10>& C_Beam::m_nAttachIndex( )
{
	static const auto offset = netvars::get_ptr( )->at("C_Beam.m_nAttachIndex");
	auto addr = utl::mem::address(this).add(offset);
	return addr.ref<utl::array<int32_t, 10>>( );
}
int32_t& C_Beam::m_nHaloIndex( )
{
	static const auto offset = netvars::get_ptr( )->at("C_Beam.m_nHaloIndex");
	auto addr = utl::mem::address(this).add(offset);
	return addr.ref<int32_t>( );
}
float& C_Beam::m_fHaloScale( )
{
	static const auto offset = netvars::get_ptr( )->at("C_Beam.m_fHaloScale");
	auto addr = utl::mem::address(this).add(offset);
	return addr.ref<float>( );
}
float& C_Beam::m_fWidth( )
{
	static const auto offset = netvars::get_ptr( )->at("C_Beam.m_fWidth");
	auto addr = utl::mem::address(this).add(offset);
	return addr.ref<float>( );
}
float& C_Beam::m_fEndWidth( )
{
	static const auto offset = netvars::get_ptr( )->at("C_Beam.m_fEndWidth");
	auto addr = utl::mem::address(this).add(offset);
	return addr.ref<float>( );
}
float& C_Beam::m_fFadeLength( )
{
	static const auto offset = netvars::get_ptr( )->at("C_Beam.m_fFadeLength");
	auto addr = utl::mem::address(this).add(offset);
	return addr.ref<float>( );
}
float& C_Beam::m_fAmplitude( )
{
	static const auto offset = netvars::get_ptr( )->at("C_Beam.m_fAmplitude");
	auto addr = utl::mem::address(this).add(offset);
	return addr.ref<float>( );
}
float& C_Beam::m_fStartFrame( )
{
	static const auto offset = netvars::get_ptr( )->at("C_Beam.m_fStartFrame");
	auto addr = utl::mem::address(this).add(offset);
	return addr.ref<float>( );
}
float& C_Beam::m_fSpeed( )
{
	static const auto offset = netvars::get_ptr( )->at("C_Beam.m_fSpeed");
	auto addr = utl::mem::address(this).add(offset);
	return addr.ref<float>( );
}
float& C_Beam::m_flFrameRate( )
{
	static const auto offset = netvars::get_ptr( )->at("C_Beam.m_flFrameRate");
	auto addr = utl::mem::address(this).add(offset);
	return addr.ref<float>( );
}
float& C_Beam::m_flHDRColorScale( )
{
	static const auto offset = netvars::get_ptr( )->at("C_Beam.m_flHDRColorScale");
	auto addr = utl::mem::address(this).add(offset);
	return addr.ref<float>( );
}
utl::Color& C_Beam::m_clrRender( )
{
	static const auto offset = netvars::get_ptr( )->at("C_Beam.m_clrRender");
	auto addr = utl::mem::address(this).add(offset);
	return addr.ref<utl::Color>( );
}
int32_t& C_Beam::m_nRenderFX( )
{
	static const auto offset = netvars::get_ptr( )->at("C_Beam.m_nRenderFX");
	auto addr = utl::mem::address(this).add(offset);
	return addr.ref<int32_t>( );
}
int32_t& C_Beam::m_nRenderMode( )
{
	static const auto offset = netvars::get_ptr( )->at("C_Beam.m_nRenderMode");
	auto addr = utl::mem::address(this).add(offset);
	return addr.ref<int32_t>( );
}
float& C_Beam::m_flFrame( )
{
	static const auto offset = netvars::get_ptr( )->at("C_Beam.m_flFrame");
	auto addr = utl::mem::address(this).add(offset);
	return addr.ref<float>( );
}
int32_t& C_Beam::m_nClipStyle( )
{
	static const auto offset = netvars::get_ptr( )->at("C_Beam.m_nClipStyle");
	auto addr = utl::mem::address(this).add(offset);
	return addr.ref<int32_t>( );
}
utl::Vector& C_Beam::m_vecEndPos( )
{
	static const auto offset = netvars::get_ptr( )->at("C_Beam.m_vecEndPos");
	auto addr = utl::mem::address(this).add(offset);
	return addr.ref<utl::Vector>( );
}
int32_t& C_Beam::m_nModelIndex( )
{
	static const auto offset = netvars::get_ptr( )->at("C_Beam.m_nModelIndex");
	auto addr = utl::mem::address(this).add(offset);
	return addr.ref<int32_t>( );
}
utl::Vector& C_Beam::m_vecOrigin( )
{
	static const auto offset = netvars::get_ptr( )->at("C_Beam.m_vecOrigin");
	auto addr = utl::mem::address(this).add(offset);
	return addr.ref<utl::Vector>( );
}
int32_t& C_Beam::moveparent( )
{
	static const auto offset = netvars::get_ptr( )->at("C_Beam.moveparent");
	auto addr = utl::mem::address(this).add(offset);
	return addr.ref<int32_t>( );
}
