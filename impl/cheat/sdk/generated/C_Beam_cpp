#include "C_Beam.h"
#include "cheat/netvars/config.h"
#ifndef CHEAT_NETVARS_UPDATING
#include "cheat/netvars/netvars.h"
#include <nstd/address.h>
#endif

#include "cheat/sdk/Color.hpp"
#include "cheat/sdk/Vector.hpp"
#include <array>
#include <cstdint>

using namespace cheat;
using namespace csgo;

Color& C_Beam::m_clrRender( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(Color*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_Beam", "m_clrRender");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<Color>( );
#endif
}
float& C_Beam::m_fAmplitude( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(float*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_Beam", "m_fAmplitude");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<float>( );
#endif
}
float& C_Beam::m_fEndWidth( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(float*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_Beam", "m_fEndWidth");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<float>( );
#endif
}
float& C_Beam::m_fFadeLength( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(float*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_Beam", "m_fFadeLength");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<float>( );
#endif
}
float& C_Beam::m_fHaloScale( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(float*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_Beam", "m_fHaloScale");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<float>( );
#endif
}
float& C_Beam::m_fSpeed( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(float*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_Beam", "m_fSpeed");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<float>( );
#endif
}
float& C_Beam::m_fStartFrame( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(float*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_Beam", "m_fStartFrame");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<float>( );
#endif
}
float& C_Beam::m_fWidth( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(float*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_Beam", "m_fWidth");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<float>( );
#endif
}
float& C_Beam::m_flFrame( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(float*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_Beam", "m_flFrame");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<float>( );
#endif
}
float& C_Beam::m_flFrameRate( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(float*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_Beam", "m_flFrameRate");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<float>( );
#endif
}
float& C_Beam::m_flHDRColorScale( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(float*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_Beam", "m_flHDRColorScale");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<float>( );
#endif
}
std::array<int32_t, 10>& C_Beam::m_hAttachEntity( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(std::array<int32_t, 10>*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_Beam", "m_hAttachEntity");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<std::array<int32_t, 10>>( );
#endif
}
std::array<int32_t, 10>& C_Beam::m_nAttachIndex( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(std::array<int32_t, 10>*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_Beam", "m_nAttachIndex");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<std::array<int32_t, 10>>( );
#endif
}
int32_t& C_Beam::m_nBeamFlags( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_Beam", "m_nBeamFlags");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
int32_t& C_Beam::m_nBeamType( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_Beam", "m_nBeamType");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
int32_t& C_Beam::m_nClipStyle( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_Beam", "m_nClipStyle");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
int32_t& C_Beam::m_nHaloIndex( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_Beam", "m_nHaloIndex");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
int32_t& C_Beam::m_nModelIndex( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_Beam", "m_nModelIndex");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
int32_t& C_Beam::m_nNumBeamEnts( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_Beam", "m_nNumBeamEnts");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
int32_t& C_Beam::m_nRenderFX( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_Beam", "m_nRenderFX");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
int32_t& C_Beam::m_nRenderMode( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_Beam", "m_nRenderMode");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
Vector& C_Beam::m_vecEndPos( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(Vector*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_Beam", "m_vecEndPos");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<Vector>( );
#endif
}
Vector& C_Beam::m_vecOrigin( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(Vector*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_Beam", "m_vecOrigin");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<Vector>( );
#endif
}
int32_t& C_Beam::moveparent( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_Beam", "moveparent");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
