#include "C_BaseCombatWeapon.h"

#include "cheat/netvars/netvars.h"

using namespace cheat;
using namespace csgo;

int32_t& C_BaseCombatWeapon::m_iPrimaryAmmoType( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon.m_iPrimaryAmmoType");
	auto addr = utl::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
int32_t& C_BaseCombatWeapon::m_iSecondaryAmmoType( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon.m_iSecondaryAmmoType");
	auto addr = utl::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
int32_t& C_BaseCombatWeapon::m_nViewModelIndex( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon.m_nViewModelIndex");
	auto addr = utl::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
bool& C_BaseCombatWeapon::m_bFlipViewModel( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(bool*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon.m_bFlipViewModel");
	auto addr = utl::address(this).add(offset);
	return addr.ref<bool>( );
#endif
}
int32_t& C_BaseCombatWeapon::m_iWeaponOrigin( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon.m_iWeaponOrigin");
	auto addr = utl::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
int32_t& C_BaseCombatWeapon::m_iWeaponModule( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon.m_iWeaponModule");
	auto addr = utl::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
float& C_BaseCombatWeapon::m_flNextPrimaryAttack( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(float*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon.m_flNextPrimaryAttack");
	auto addr = utl::address(this).add(offset);
	return addr.ref<float>( );
#endif
}
float& C_BaseCombatWeapon::m_flNextSecondaryAttack( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(float*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon.m_flNextSecondaryAttack");
	auto addr = utl::address(this).add(offset);
	return addr.ref<float>( );
#endif
}
int32_t& C_BaseCombatWeapon::m_nNextThinkTick( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon.m_nNextThinkTick");
	auto addr = utl::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
float& C_BaseCombatWeapon::m_flTimeWeaponIdle( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(float*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon.m_flTimeWeaponIdle");
	auto addr = utl::address(this).add(offset);
	return addr.ref<float>( );
#endif
}
int32_t& C_BaseCombatWeapon::m_iViewModelIndex( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon.m_iViewModelIndex");
	auto addr = utl::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
int32_t& C_BaseCombatWeapon::m_iWorldModelIndex( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon.m_iWorldModelIndex");
	auto addr = utl::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
int32_t& C_BaseCombatWeapon::m_iWorldDroppedModelIndex( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon.m_iWorldDroppedModelIndex");
	auto addr = utl::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
int32_t& C_BaseCombatWeapon::m_iState( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon.m_iState");
	auto addr = utl::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
CBaseHandle& C_BaseCombatWeapon::m_hOwner( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(CBaseHandle*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon.m_hOwner");
	auto addr = utl::address(this).add(offset);
	return addr.ref<CBaseHandle>( );
#endif
}
int32_t& C_BaseCombatWeapon::m_iClip1( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon.m_iClip1");
	auto addr = utl::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
int32_t& C_BaseCombatWeapon::m_iClip2( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon.m_iClip2");
	auto addr = utl::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
int32_t& C_BaseCombatWeapon::m_iPrimaryReserveAmmoCount( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon.m_iPrimaryReserveAmmoCount");
	auto addr = utl::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
int32_t& C_BaseCombatWeapon::m_iSecondaryReserveAmmoCount( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon.m_iSecondaryReserveAmmoCount");
	auto addr = utl::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
CBaseHandle& C_BaseCombatWeapon::m_hWeaponWorldModel( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(CBaseHandle*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon.m_hWeaponWorldModel");
	auto addr = utl::address(this).add(offset);
	return addr.ref<CBaseHandle>( );
#endif
}
int32_t& C_BaseCombatWeapon::m_iNumEmptyAttacks( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon.m_iNumEmptyAttacks");
	auto addr = utl::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
