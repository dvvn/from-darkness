#include "C_BaseCombatWeapon.h"
#include "cheat/netvars/config.h"
#ifndef CHEAT_NETVARS_UPDATING
#include "cheat/netvars/netvars.h"
#include <nstd/address.h>
#endif

#include "cheat/sdk/CBaseHandle.hpp"
#include <cstdint>

using namespace cheat;
using namespace csgo;

bool& C_BaseCombatWeapon::m_bFlipViewModel( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(bool*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon", "m_bFlipViewModel");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<bool>( );
#endif
}
float& C_BaseCombatWeapon::m_flNextPrimaryAttack( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(float*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon", "m_flNextPrimaryAttack");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<float>( );
#endif
}
float& C_BaseCombatWeapon::m_flNextSecondaryAttack( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(float*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon", "m_flNextSecondaryAttack");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<float>( );
#endif
}
float& C_BaseCombatWeapon::m_flTimeWeaponIdle( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(float*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon", "m_flTimeWeaponIdle");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<float>( );
#endif
}
CBaseHandle& C_BaseCombatWeapon::m_hOwner( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(CBaseHandle*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon", "m_hOwner");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<CBaseHandle>( );
#endif
}
CBaseHandle& C_BaseCombatWeapon::m_hWeaponWorldModel( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(CBaseHandle*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon", "m_hWeaponWorldModel");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<CBaseHandle>( );
#endif
}
int32_t& C_BaseCombatWeapon::m_iClip1( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon", "m_iClip1");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
int32_t& C_BaseCombatWeapon::m_iClip2( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon", "m_iClip2");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
int32_t& C_BaseCombatWeapon::m_iNumEmptyAttacks( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon", "m_iNumEmptyAttacks");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
int32_t& C_BaseCombatWeapon::m_iPrimaryAmmoType( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon", "m_iPrimaryAmmoType");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
int32_t& C_BaseCombatWeapon::m_iPrimaryReserveAmmoCount( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon", "m_iPrimaryReserveAmmoCount");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
int32_t& C_BaseCombatWeapon::m_iSecondaryAmmoType( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon", "m_iSecondaryAmmoType");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
int32_t& C_BaseCombatWeapon::m_iSecondaryReserveAmmoCount( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon", "m_iSecondaryReserveAmmoCount");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
int32_t& C_BaseCombatWeapon::m_iState( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon", "m_iState");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
int32_t& C_BaseCombatWeapon::m_iViewModelIndex( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon", "m_iViewModelIndex");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
int32_t& C_BaseCombatWeapon::m_iWeaponModule( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon", "m_iWeaponModule");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
int32_t& C_BaseCombatWeapon::m_iWeaponOrigin( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon", "m_iWeaponOrigin");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
int32_t& C_BaseCombatWeapon::m_iWorldDroppedModelIndex( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon", "m_iWorldDroppedModelIndex");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
int32_t& C_BaseCombatWeapon::m_iWorldModelIndex( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon", "m_iWorldModelIndex");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
int32_t& C_BaseCombatWeapon::m_nNextThinkTick( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon", "m_nNextThinkTick");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
int32_t& C_BaseCombatWeapon::m_nViewModelIndex( )
{
#ifdef CHEAT_NETVARS_UPDATING
	return *(int32_t*)nullptr;
#else
	static const auto offset = netvars::get_ptr( )->at("C_BaseCombatWeapon", "m_nViewModelIndex");
	auto addr = nstd::address(this).add(offset);
	return addr.ref<int32_t>( );
#endif
}
